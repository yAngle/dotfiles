#!/usr/bin/env python2

import imp
import sys
import os.path as op
import re

from pandocfilters import toJSONFilter, RawBlock, RawInline
from pygments import highlight, lexers, formatters


VERBATIM_RE = re.compile(
    r'\\begin\{Verbatim\}'
    r'(\[[^\]]+\])?'  # Optional arguments
    r'\n*'
    r'(?P<inside>.*?)'
    r'\n*'
    r'\\end\{Verbatim\}'
    r'\n*$',
    re.MULTILINE
)


def pygments(key, value, fmt, meta):
    r"""
    Apply pygments syntax highlighting to code blocks

    Optionally, wrap a fenced code block marked as "equation" inside a
    FakeEquation environment, so that

        ```{.python .equation label=eq:func}
        def func():
            pass
        ```

    will (in effect) become

        \begin{equation}
        \label{eq:func}
        ...
        \end{equation}
    """
    if key not in ('Code', 'CodeBlock'):
        return None

    # Load extra python modules specified in metadata block.
    # This is intended for monkey patching.
    if 'python-extras' in meta:
        assert meta['python-extras']['t'] == 'MetaList'
        for entry in meta['python-extras']['c']:
            module_path = op.expanduser(entry['c'][0]['c'])
            module = op.splitext(op.basename(module_path))[0]
            if module not in sys.modules:
                imp.load_source(module, module_path)

    # Parse markdown fenced block header like "{.python .equation}".
    # http://pandoc.org/MANUAL.html#extension-fenced_code_attributes
    (_, classes, attrs), code = value
    as_equation = ('equation' in classes and
                   fmt == 'latex' and
                   key == 'CodeBlock')  # makes no sense for inline Code

    # Skip inline code with no "{.lang}" attributes, as Verbatim generated by
    # pygments cannot be put into a table. Leave it to the caller to ensure
    # that "{.lang}" attributes are specified only ouside of a table.
    # https://tex.stackexchange.com/a/234301
    if key == 'Code' and not classes:
        return None

    for lang in classes:
        try:
            lexer = lexers.get_lexer_by_name(lang)
            break
        except Exception:
            pass
    else:
        lexer = lexers.TextLexer()

    # Use "BVerbatim" in equation mode so that \centering can be applied.
    # Otherwise, use the plain "Verbatim" to allow page breaks.
    # https://tex.stackexchange.com/a/122197
    envname = 'BVerbatim' if as_equation else 'Verbatim'
    formatter = formatters.get_formatter_by_name(fmt, envname=envname)
    output = highlight(code, lexer, formatter)

    if key == 'Code':
        output = r'\texttt{%s}' % VERBATIM_RE.match(output).group('inside')
        return [RawInline(fmt, output)]

    # Add a FakeEquation wrapper (defined in report.latex template).
    if as_equation:
        label = dict(attrs).get('label', '')
        template = r'\begin{FakeEquation}[%s]%s\end{FakeEquation}'
        output = template % (label, output)

    return [RawBlock(fmt, output)]


if __name__ == "__main__":
    toJSONFilter(pygments)
