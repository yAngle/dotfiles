#!/usr/bin/env python2

"""Draw JSON generated by jsonfig.py, using matplotlib

All the documentations are in jsonfig.py
"""

import sys
import time
from datetime import datetime
from dateutil.parser import parse as parse_date
import json
from pprint import pprint

import matplotlib
import matplotlib.pyplot as plt
from matplotlib.font_manager import FontProperties
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.backends.backend_agg import FigureCanvasAgg
from matplotlib.transforms import TransformedBbox, Bbox
from matplotlib.transforms import blended_transform_factory
from matplotlib.ticker import MaxNLocator, LogLocator

from utils import DotDict as D

def plot_json(js, silent=True):
    # load script
    _fig = json.loads(js, object_hook=D)
    if not silent:
        pprint(_fig)

    # strip internals
    strip_ = lambda d: D({name: value for name, value in d.iteritems() if not name.startswith('_')})

    # build figure and axes
    if '_subplots' in _fig:
        d = dict(strip_(_fig._subplots))
        d.update(strip_(_fig))
        fig, axes = plt.subplots(**d)
        axes = axes.flatten()
        if len(_fig._axes) > len(axes):
            assert all(ax._is_twinx_of is not None for ax in _fig._axes[len(axes):])
            axes += [axes[ax._is_twin_of].twinx() for ax in _fig._axes[len(axes):]]
    else:
        fig = plt.figure(**strip_(_fig))
        # if ax lbwh is not provided, we put in some trial value here. The final layout is determined dynamically
        axes = [fig.add_axes(_ax._lbwh or [0.13, 0.16, 0.84, 0.79], **strip_(_ax)) if (_ax._is_twinx_of is None) else None
                for _ax in _fig._axes]
        for i in xrange(len(axes)):
            if axes[i] == None:
                axes[i] = axes[_fig._axes[i]._is_twinx_of].twinx()

    # plot each set of axes
    naxes = sum(1 for _ax in _fig._axes if _ax._is_twinx_of is not None)
    for ax_index, (ax, _ax) in enumerate(zip(axes, _fig._axes)):
        # tweak label position
        if '_x_top' in _ax and _ax._x_top:
            ax.xaxis.tick_top()
            ax.xaxis.set_label_position('top')
        if '_y_right' in _ax and _ax._y_right:
            ax.yaxis.tick_right()
            ax.yaxis.set_label_position('right')

        # set ax attributes
        for key, setting in sorted(_ax._settings.iteritems()): # HACK: 'sorted' ensures that set_xtick{label}s() is called after set_scale('log')
            if isinstance(setting, list):
                for s in setting:
                    if key == 'tick_properties':
                        assert len(s._args) == 2 and s._args[0] in 'xy' and s._args[1] in ('major', 'minor')
                        axis = ax.xaxis if s._args[0] == 'x' else ax.yaxis
                        axis.set_tick_params(which=s._args[1], **strip_(s))
                    elif key in ('xmajorticksize', 'xminorticksize', 'ymajorticksize', 'yminorticksize'):
                        axis = ax.xaxis if key.startswith('x') else ax.yaxis
                        axis.set_tick_params(which='major' if 'major' in key else 'minor', **{'length': s._args[0]})
                    else:
                        getattr(ax, 'set_%s' % key)(*s._args, **strip_(s))
            else: # backward compatible
                getattr(ax, 'set_%s' % key)(*setting._args, **strip_(setting))

        # draw each layer
        layers = []
        for _layer in _ax._layers:
            actor = D(scatter=ax.scatter, plot=ax.plot, Line2D=matplotlib.lines.Line2D)[_layer._type]
            handle = actor(*_layer._args, **strip_(_layer))
            layers.append(handle)

        # build legend
        if '_legend' in _ax:
            _legend = _ax._legend
            handles = [layers[i] for i in _legend._indices]
            leg = ax.legend(handles, _legend._labels, prop=FontProperties(size=_legend._fontsize), **strip_(_legend))
            leg.get_frame().set_alpha(_legend._alpha)


        def make_transform(_transform):
            """build Transform object from 'data', 'ax', 'fig', or 2-tuple of them"""
            transforms = D(ax=ax.transAxes, data=ax.transData, fig=fig.transFigure)
            if isinstance(_transform, list) or isinstance(_transform, tuple):
                assert len(_transform) == 2
                return blended_transform_factory(transforms[_transform[0]], transforms[_transform[1]])
            else:
                return transforms[_transform]

        # write texts
        for _text in _ax._texts:
            # _text._transform can be ('ax', 'data', 'fig')
            actor = D(ax=ax.transAxes, data=ax.transData, fig=fig.transFigure)
            kwargs = strip_(_text)
            kwargs.transform = 'data' if '_transform' not in _text else make_transform(_text._transform)
            ax.text(*_text._args, **kwargs)

        # annotate
        for _annotate in _ax._annotations:
            # _annotate._transform can be ('ax', 'data', 'fig')
            actor = D(ax=ax.transAxes, data=ax.transData, fig=fig.transFigure)
            kwargs = strip_(_annotate)
            if 'xycoords' in _annotate and (isinstance(_annotate.xycoords, list) or isinstance(_annotate.xycoords, tuple)):
                kwargs.xycoords = make_transform(_annotate._xycoords)
            if 'textcoords' in _annotate and (isinstance(_annotate.textcoords, list) or isinstance(_annotate.textcoords, tuple)):
                kwargs.textcoords = make_transform(_annotate._textcoords)
            ax.annotate(*_annotate._args, **kwargs)

        # draw ax*lines
        for _line in _ax._axlines:
            actor = D(h=ax.axhline, v=ax.axvline)[_line._direction]
            actor(*_line._args, **strip_(_line))

        # subplot label
        if naxes > 1 and _ax._is_twinx_of is None:
            props = dict(boxstyle='round', facecolor='wheat', alpha=0.85)
            n = sum(1 for _ax in _fig._axes[:ax_index] if _ax._is_twinx_of is not None)
            text = r'\textbf{%s)}' % chr(ord('a') + ax_index - n)
            ax.text(0.07, 0.94, text, ha='center', va='center', size=8, color=[0.3, 0.3, 0.3], transform=ax.transAxes, zorder=-10)

    # maximize ax size
    if all(_ax._lbwh is None for _ax in _fig._axes):
        if len(_fig._axes) == 1:
            maximize_single_ax(fig)
        elif '_subplots' in _fig:
            maximize_subplots(fig, _fig._subplots)
        else:
            pass

    # save to pdf
    figname = _fig._figname or time.strftime('%y%m%d-%H%M%S.pdf')
    pdf = PdfPages(figname)

    # metadata
    d = pdf.infodict()
    d.update({key: (value if 'Date' not in key else parse_date(value))
              for key, value in _fig._infodict.iteritems()})
    d['ModDate'] = datetime.today() # CreationDate - json, ModDate - pdf
    pdf.savefig(fig)
    plt.close()
    pdf.close()
    print 'Plotted', figname

def maximize_single_ax(fig, margin=0.005):
    """tight layout for a single ax"""
    canvas = FigureCanvasAgg(fig)
    renderer = canvas.get_renderer()
    ax, = fig.get_axes() # assume single axes

    # bounding box of all the elements, size relative to figure
    full = TransformedBbox(ax.get_tightbbox(renderer), fig.transFigure.inverted()).get_points()
    # original rect (core region, without axis labels / tick labels)
    core = ax.get_position().get_points()

    margin_left, margin_bottom = core[0] - full[0]
    margin_right, margin_top = full[1] - core[1]

    pos = [margin_left + margin,
           margin_bottom + margin,
           1 - 2 * margin - margin_left - margin_right,
           1 - 2 * margin - margin_bottom - margin_top]
    # TODO: add a switch to write the choice to file
    print 'lbwh =', pos
    ax.set_position(pos)

def maximize_subplots(fig, subplots):
    """tight layout for subplots"""
    #TODO this works only for sharex = sharey = True now, and it tries to make axis size uniform
    # should be able to handle variable axis size
    nrows, ncols, sharex, sharey = subplots.nrows, subplots.ncols, subplots.sharex, subplots.sharey
    margin, wspace, hspace = subplots._margin, subplots._wspace, subplots._hspace

    canvas = FigureCanvasAgg(fig)
    renderer = canvas.get_renderer()

    plt.tight_layout()
    plt.subplots_adjust(wspace=wspace, hspace=hspace)

    axes = fig.get_axes()
    full = [TransformedBbox(ax.get_tightbbox(renderer), fig.transFigure.inverted()).get_points() for ax in axes]
    core = [ax.get_position().get_points() for ax in axes]

    f = lambda row, col: full[row * ncols + col]
    c = lambda row, col: core[row * ncols + col]

    # extra space taken by axis labels / ticklabels, for each subplot
    extra_l = lambda row, col: c(row, col)[0][0] - f(row, col)[0][0]
    extra_b = lambda row, col: c(row, col)[0][1] - f(row, col)[0][1]
    extra_r = lambda row, col: f(row, col)[1][0] - c(row, col)[1][0]
    extra_t = lambda row, col: f(row, col)[1][1] - c(row, col)[1][1]

    # extra space for each row / col
    max_extra_l = lambda col: max(extra_l(row, col) for row in xrange(nrows))
    max_extra_r = lambda col: max(extra_r(row, col) for row in xrange(nrows))
    max_extra_b = lambda row: max(extra_b(row, col) for col in xrange(ncols))
    max_extra_t = lambda row: max(extra_t(row, col) for col in xrange(ncols))

    total_w = 1 - sum(max_extra_l(col) + max_extra_r(col) for col in xrange(ncols))
    total_h = 1 - sum(max_extra_b(row) + max_extra_t(row) for row in xrange(nrows))

    w = (total_w - 2 * margin - wspace * (ncols - 1)) / ncols
    h = (total_h - 2 * margin - hspace * (nrows - 1)) / nrows
    b = 1 - margin
    for row in xrange(nrows):
        l = margin
        b -= max_extra_t(row) + h
        for col in xrange(ncols):
            l += max_extra_l(col)
            axes[row * ncols + col].set_position([l, b, w, h])
            print 'lbwh =', [l, b, w, h]
            l += w + max_extra_r(col)
            l += wspace
        b -= max_extra_b(row)
        b -= hspace

def test_draw():
    from prepare import test_subplot
    js = test_subplot()
    plot_json(js)

if __name__ == '__main__':
    if len(sys.argv) != 2:
        print 'usage: draw-json figure.json'
    else:
        with open(sys.argv[1]) as f:
            plot_json(f.read())

