#!/usr/bin/env python2

"""Draw JSON generated by jsonfig.py, using matplotlib

All the documentations are in jsonfig.py
"""

import sys
import time
from datetime import datetime
from dateutil.parser import parse as parse_date
import json
from pprint import pprint

import matplotlib
import matplotlib.pyplot as plt
from matplotlib.font_manager import FontProperties
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.backends.backend_agg import FigureCanvasAgg
from matplotlib.transforms import TransformedBbox, Bbox
from matplotlib.transforms import blended_transform_factory

from utils import DotDict as D

def plot_json(js, silent=True):
    # load script
    _fig = json.loads(js, object_hook=D)
    if not silent:
        pprint(_fig)

    # strip internals
    strip_ = lambda d: D({name: value for name, value in d.iteritems() if not name.startswith('_')})

    # build figure and axes
    if '_subplots' in _fig:
        d = dict(strip_(_fig._subplots))
        d.update(strip_(_fig))
        fig, axes = plt.subplots(**d)
        axes = axes.flatten()
    else:
        fig = plt.figure(**strip_(_fig))
        axes = [fig.add_axes(_ax._lbwh or [0.13, 0.16, 0.84, 0.79], **strip_(_ax)) for _ax in _fig._axes]
        # if ax lbwh is not provided, we put in some trial value here. The final layout is determined dynamically

    # plot each set of axes
    for ax_index, (ax, _ax) in enumerate(zip(axes, _fig._axes)):
        # draw each layer
        layers = []
        for _layer in _ax._layers:
            actor = D(scatter=ax.scatter, plot=ax.plot, Line2D=matplotlib.lines.Line2D)[_layer._type]
            handle = actor(*_layer._args, **strip_(_layer))
            layers.append(handle)

        # build legend
        if '_legend' in _ax:
            _legend = _ax._legend
            handles = [layers[i] for i in _legend._indices]
            leg = ax.legend(handles, _legend._labels, prop=FontProperties(size=_legend._fontsize), **strip_(_legend))
            leg.get_frame().set_alpha(_legend._alpha)

        # write texts
        for _text in _ax._texts:
            # _text._transform can be ('ax', 'data', 'fig')
            actor = D(ax=ax.transAxes, data=ax.transData, fig=fig.transFigure)
            if isinstance(_text._transform, list):
                transform = blended_transform_factory(actor[_text._transform[0]], actor[_text._transform[1]])
            else:
                transform = actor[_text._transform]
            ax.text(*_text._args, transform=transform, **strip_(_text))

        # draw ax*lines
        for _line in _ax._axlines:
            actor = D(h=ax.axhline, v=ax.axvline)[_line._direction]
            actor(*_line._args, **strip_(_line))

        # set ax attributes
        for key, setting in _ax._settings.iteritems():
            if isinstance(setting, list):
                for s in setting:
                    getattr(ax, 'set_%s' % key)(*s._args, **strip_(s))
            else: # backward compatible
                getattr(ax, 'set_%s' % key)(*setting._args, **strip_(setting))

        # subplot label
        if len(axes) > 1:
            props = dict(boxstyle='round', facecolor='wheat', alpha=0.85)
            ax.text(0.07, 0.94, r'\textbf{%s)}' % chr(ord('a') + ax_index), ha='center', va='center', size=8, color=[0.3, 0.3, 0.3], transform=ax.transAxes, zorder=-10)

    # maximize ax size
    if all(_ax._lbwh is None for _ax in _fig._axes):
        if len(_fig._axes) == 1:
            maximize_single_ax(fig)
        elif '_subplots' in _fig:
            maximize_subplots(fig, _fig._subplots)
        else:
            pass

    # save to pdf
    figname = _fig._figname or time.strftime('%y%m%d-%H%M%S.pdf')
    pdf = PdfPages(figname)

    # metadata
    d = pdf.infodict()
    d.update({key: (value if 'Date' not in key else parse_date(value))
              for key, value in _fig._infodict.iteritems()})
    d['ModDate'] = datetime.today() # CreationDate - json, ModDate - pdf
    pdf.savefig(fig)
    plt.close()
    pdf.close()
    print 'Plotted', figname

def maximize_single_ax(fig, margin=0.005):
    """tight layout for a single ax"""
    canvas = FigureCanvasAgg(fig)
    renderer = canvas.get_renderer()
    ax, = fig.get_axes() # assume single axes

    # bounding box of all the elements, size relative to figure
    full = TransformedBbox(ax.get_tightbbox(renderer), fig.transFigure.inverted()).get_points()
    # original rect (core region, without axis labels / tick labels)
    core = ax.get_position().get_points()

    margin_left, margin_bottom = core[0] - full[0]
    margin_right, margin_top = full[1] - core[1]

    pos = [margin_left + margin,
           margin_bottom + margin,
           1 - 2 * margin - margin_left - margin_right,
           1 - 2 * margin - margin_bottom - margin_top]
    # TODO: add a switch to write the choice to file
    #print 'lbwh =', pos
    ax.set_position(pos)

def maximize_subplots(fig, subplots):
    """tight layout for subplots"""
    #TODO this works only for sharex = sharey = True now, and it tries to make axis size uniform
    # should be able to handle variable axis size
    nrows, ncols, sharex, sharey = subplots.nrows, subplots.ncols, subplots.sharex, subplots.sharey
    margin, wspace, hspace = subplots._margin, subplots._wspace, subplots._hspace

    canvas = FigureCanvasAgg(fig)
    renderer = canvas.get_renderer()

    plt.tight_layout()
    plt.subplots_adjust(wspace=wspace, hspace=hspace)

    axes = fig.get_axes()
    full = [TransformedBbox(ax.get_tightbbox(renderer), fig.transFigure.inverted()).get_points() for ax in axes]
    core = [ax.get_position().get_points() for ax in axes]

    f = lambda row, col: full[row * ncols + col]
    c = lambda row, col: core[row * ncols + col]

    # extra space taken by axis labels / ticklabels, for each subplot
    extra_l = lambda row, col: c(row, col)[0][0] - f(row, col)[0][0]
    extra_b = lambda row, col: c(row, col)[0][1] - f(row, col)[0][1]
    extra_r = lambda row, col: f(row, col)[1][0] - c(row, col)[1][0]
    extra_t = lambda row, col: f(row, col)[1][1] - c(row, col)[1][1]

    # extra space for each row / col
    max_extra_l = lambda col: max(extra_l(row, col) for row in xrange(nrows))
    max_extra_r = lambda col: max(extra_r(row, col) for row in xrange(nrows))
    max_extra_b = lambda row: max(extra_b(row, col) for col in xrange(ncols))
    max_extra_t = lambda row: max(extra_t(row, col) for col in xrange(ncols))

    total_w = 1 - sum(max_extra_l(col) + max_extra_r(col) for col in xrange(ncols))
    total_h = 1 - sum(max_extra_b(row) + max_extra_t(row) for row in xrange(nrows))

    w = (total_w - 2 * margin - wspace * (ncols - 1)) / ncols
    h = (total_h - 2 * margin - hspace * (nrows - 1)) / nrows
    b = 1 - margin
    for row in xrange(nrows):
        l = margin
        b -= max_extra_t(row) + h
        for col in xrange(ncols):
            l += max_extra_l(col)
            axes[row * ncols + col].set_position([l, b, w, h])
            print 'lbwh =', [l, b, w, h]
            l += w + max_extra_r(col)
            l += wspace
        b -= max_extra_b(row)
        b -= hspace

def test_draw():
    from prepare import test_subplot
    js = test_subplot()
    plot_json(js)

if __name__ == '__main__':
    if len(sys.argv) != 2:
        print 'usage: draw-json figure.json'
    else:
        with open(sys.argv[1]) as f:
            plot_json(f.read())

